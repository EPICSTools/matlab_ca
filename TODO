
- More/different semaphores for monitor data structures,
  comments in Channel.cpp
  
- Investigate one quirky IOC crash:
When running the put-callback test against a 3.14.8.2 softIoc
on Mac OS X, the IOC will sometimes crash:

p1 = mcaopen('set1'); p2 = mcaopen('set1.DESC');
mcaput({p1, p2}, {42, 'Description'});
% The immediate follow-up of 'put' and 'close' does it
mcaclose(p2, p1);

This is highly dependent on the exact timing of things.
What prevents the crash:
- Enabling debug prints that slow the overall execution
- Running Matlab from the command-line without the GUI
- An added 'pause' before the close

Symptom on the IOC:

epicsEvent pthread_mutex_lock failed: error Invalid argument
fatal error: epicsEventSignal
filename="../../../src/libCom/taskwd/taskwd.c" line number=174
task 0x646c00 suspended

One can run the test again and again, each time creating
another suspended thread, like two in this example:
      
epics> thread
            NAME     EPICS ID   PTHREAD ID   OSIPRI  OSSPRI  STATE
          _main_     0x600630            0      0       0       OK
      timerQueue     0x640bf0     25200128     70      37       OK
           cbLow     0x640d80     25201152     59      33       OK
        cbMedium     0x640ec0     25202176     64      35       OK
          cbHigh     0x641000     25236992     71      37       OK
          errlog     0x6403a0     25195008     10      18       OK
          taskwd     0x6405e0     25199104     10      18       OK
        dbCaLink     0x641290     25238016     50      31       OK
        scanOnce     0x641f80     25244160     70      37       OK
          scan10     0x642530     25245184     60      34       OK
           scan5     0x642610     25246208     61      34       OK
           scan2     0x6426f0     25247232     62      34       OK
           scan1     0x6427d0     25248256     63      35       OK
         scan0.5     0x6428b0     25249280     64      35       OK
         scan0.2     0x642990     25250304     65      35       OK
         scan0.1     0x642a70     25251328     66      36       OK
         CAS-TCP     0x643030     25252352     12      18       OK
      CAS-beacon     0x643120     25253376      8      17       OK
         CAS-UDP     0x643220     25257984      4      16       OK
       CAS-event     0x646ce0     25254400     16      20  SUSPEND
       CAS-event     0x646c00     25279488     16      20  SUSPEND
      
The view in the debugger is useless with 'optimization' on, but the error
happens the same with and w/o, so here's the info when compiling base
w/o optimization:

(gdb) info threads
  21 process 16955 thread 0x3857  0x9002bbc8 in semaphore_wait_signal_trap ()
  20 process 16955 thread 0x355b  0x9002bbc8 in semaphore_wait_signal_trap ()
  19 process 16955 thread 0x3303  0x90023460 in recvfrom ()
  18 process 16955 thread 0x3103  0x90040978 in mach_wait_until ()
  17 process 16955 thread 0x2f03  0x9005b660 in accept ()
  16 process 16955 thread 0x2e03  0x90040978 in mach_wait_until ()
  15 process 16955 thread 0x2d03  0x90040978 in mach_wait_until ()
  14 process 16955 thread 0x2c03  0x90040978 in mach_wait_until ()
  13 process 16955 thread 0x2b03  0x90040978 in mach_wait_until ()
  12 process 16955 thread 0x2a03  0x90040978 in mach_wait_until ()
  11 process 16955 thread 0x2903  0x90040978 in mach_wait_until ()
  10 process 16955 thread 0x2803  0x90040978 in mach_wait_until ()
  9 process 16955 thread 0x2703  0x9002bbc8 in semaphore_wait_signal_trap ()
  8 process 16955 thread 0x2603  0x9002bbc8 in semaphore_wait_signal_trap ()
  7 process 16955 thread 0x2503  0x9002bbc8 in semaphore_wait_signal_trap ()
  6 process 16955 thread 0x2403  0x9002bbc8 in semaphore_wait_signal_trap ()
  5 process 16955 thread 0x2303  0x9002bbc8 in semaphore_wait_signal_trap ()
  4 process 16955 thread 0x1103  0x90054ae8 in semaphore_timedwait_signal_trap ()
  3 process 16955 thread 0x1003  0x90040978 in mach_wait_until ()
  2 process 16955 thread 0xf03  0x9002bbc8 in semaphore_wait_signal_trap ()
* 1 process 16955 thread 0xd03  0x900140a4 in read ()

As for the mapping of the softIoc 'thread' listing to the GDB 'info threads':
Backtrace checks suggest: GDB thread 1 = '_main_', the two listings are in
reverse order, so the two suspended threads are GDB threads 20 and 21:

(gdb) thread 20
[Switching to thread 20 (process 16955 thread 0x355b)]
#0  0x9002bbc8 in semaphore_wait_signal_trap ()
(gdb) bt
#0  0x9002bbc8 in semaphore_wait_signal_trap ()
#1  0x900306ac in pthread_cond_wait ()
#2  0x0046b9f4 in condWait (condId=0x646aac, mutexId=0x646a80) at ../../../src/libCom/osi/os/posix/osdEvent.c:75
#3  0x0046be7c in epicsEventWait (pevent=0x646a80) at ../../../src/libCom/osi/os/posix/osdEvent.c:137
#4  0x00469e10 in epicsThreadSuspendSelf () at ../../../src/libCom/osi/os/posix/osdThread.c:473
#5  0x0045b0f4 in cantProceed (errorMessage=0x47e29c "epicsEventSignal") at ../../../src/libCom/misc/cantProceed.c:53
#6  0x0046bd04 in epicsEventSignal (pevent=0x646ba0) at ../../../src/libCom/osi/os/posix/osdEvent.c:118
#7  0x002b4998 in write_notify_reply (pArg=0x1816ff0) at ../camessage.c:1490
#8  0x0031606c in event_task (pParm=0x5df614) at ../dbEvent.c:972
#9  0x004695f4 in start_routine (arg=0x646ce0) at ../../../src/libCom/osi/os/posix/osdThread.c:320
#10 0x9002b508 in _pthread_body ()
(gdb) thread 21
[Switching to thread 21 (process 16955 thread 0x3857)]
#0  0x9002bbc8 in semaphore_wait_signal_trap ()
(gdb) bt
#0  0x9002bbc8 in semaphore_wait_signal_trap ()
#1  0x900306ac in pthread_cond_wait ()
#2  0x0046b9f4 in condWait (condId=0x6470ec, mutexId=0x6470c0) at ../../../src/libCom/osi/os/posix/osdEvent.c:75
#3  0x0046be7c in epicsEventWait (pevent=0x6470c0) at ../../../src/libCom/osi/os/posix/osdEvent.c:137
#4  0x00469e10 in epicsThreadSuspendSelf () at ../../../src/libCom/osi/os/posix/osdThread.c:473
#5  0x0045b0f4 in cantProceed (errorMessage=0x47e29c "epicsEventSignal") at ../../../src/libCom/misc/cantProceed.c:53
#6  0x0046bd04 in epicsEventSignal (pevent=0x646700) at ../../../src/libCom/osi/os/posix/osdEvent.c:118
#7  0x002b4998 in write_notify_reply (pArg=0x1816ff0) at ../camessage.c:1490
#8  0x0031606c in event_task (pParm=0x5de9c8) at ../dbEvent.c:972
#9  0x004695f4 in start_routine (arg=0x646c00) at ../../../src/libCom/osi/os/posix/osdThread.c:320
#10 0x9002b508 in _pthread_body ()


Some more detail:

(gdb) fra 6
#6  0x0046bd04 in epicsEventSignal (pevent=0x646700) at ../../../src/libCom/osi/os/posix/osdEvent.c:118
118         checkStatusQuit(status,"pthread_mutex_lock","epicsEventSignal");
(gdb) print *pevent
$5 = {
  mutex = {
    __sig = 13691, 
    __opaque = "\000\000\000\000\000\000\000\000\000\005", '\0' <repeats 29 times>
  }, 
  cond = {
    __sig = 0, 
    __opaque = '\0' <repeats 23 times>
  }, 
  isFull = 0
}
(gdb) print status
$6 = 22

(gdb) fra 8
#8  0x0031606c in event_task (pParm=0x5de9c8) at ../dbEvent.c:972
972                 (*evUser->extralabor_sub)(evUser->extralabor_arg);
(gdb) print *evUser
$1 = {
  firstque = {
    writelock = 0x646d60, 
    valque = {{
        stat = 0, 
        sevr = 0, 
        time = {
          secPastEpoch = 0, 
          nsec = 0
        }, 
        field = {
          dbf_int = 0, 
          dbf_short = 0, 
          dbf_float = 0, 
          dbf_enum = 0, 
          dbf_char = 0 '\0', 
          dbf_long = 0, 
          dbf_double = 0
        }
      } <repeats 128 times>}, 
    evque = {0x0 <repeats 128 times>}, 
    nextque = 0x0, 
    evUser = 0x5de9c8, 
    putix = 0, 
    getix = 0, 
    quota = 0, 
    nDuplicates = 0, 
    nCanceled = 0
  }, 
  lock = 0x640cb0, 
  ppendsem = 0x646b30, 
  pflush_sem = 0x647010, 
  overflow_sub = 0, 
  overflow_arg = 0x0, 
  extralabor_sub = 0, 
  extralabor_arg = 0x0, 
  taskid = 0x646c00, 
  pSuicideEvent = 0x0, 
  queovr = 0, 
  pendexit = 1 '\001', 
  extra_labor = 0 '\0', 
  flowCtrlMode = 0 '\0', 
  extraLaborBusy = 0 '\0', 
  init_func = 0, 
  init_func_arg = 0x0
}

(gdb) fra 7
#7  0x002b4998 in write_notify_reply (pArg=0x1816ff0) at ../camessage.c:1490
1490        epicsEventSignal ( pClient->blockSem );
(gdb) print *pClient
$4 = {
  node = {
    next = 0x1816f48, 
    previous = 0x0
  }, 
  send = {
    buf = 0x5d2000 "", 
    stk = 0, 
    maxstk = 16384, 
    cnt = 0, 
    type = mbtSmallTCP
  }, 
  recv = {
    buf = 0x5d6000 "", 
    stk = 0, 
    maxstk = 16384, 
    cnt = 0, 
    type = mbtSmallTCP
  }, 
  lock = 0x6467e0, 
  putNotifyLock = 0x646760, 
  addrqLock = 0x6466e0, 
  eventqLock = 0x646660, 
  addrq = {
    node = {
      next = 0x0, 
      previous = 0x0
    }, 
    count = 0
  }, 
  putNotifyQue = {
    node = {
      next = 0x0, 
      previous = 0x0
    }, 
    count = 0
  }, 
  addr = {
    sin_len = 16 '\020', 
    sin_family = 2 '\002', 
    sin_port = 53632, 
    sin_addr = {
      s_addr = 2690378835
    }, 
    sin_zero = "\000\000\000\000\000\000\000"
  }, 
  time_at_last_send = {
    secPastEpoch = 531157886, 
    nsec = 712966000
  }, 
  time_at_last_recv = {
    secPastEpoch = 531157886, 
    nsec = 712422000
  }, 
  evuser = 0x5ddd7c, 
  pUserName = 0x647450 "", 
  pHostName = 0x647460 "thread", 
  blockSem = 0x646700, 
  sock = 9, 
  proto = 6, 
  tid = 0x647370, 
  minor_version_number = 11, 
  seqNoOfReq = 0, 
  recvBytesToDrain = 0, 
  priority = 0, 
  disconnect = 0 '\0'
}


Amongth the things I don't understand: Note the
   pHostName = 0x647460 "thread"
towards the end of the last structure.
That "thread" happens to be the last command that I typed in the
IOC shell. It should have nothing to do with an internal data
structure of write_notify_reply().



==== 

More details:
Highly dependent on timing.
'printf's can change everything.
Instrumented code shows this order on the IOC:
1) create_client
2) destroy_client
    deletes the blockSem
3) write_notify_reply crashes in 
    epicsEventSignal ( pClient->blockSem );

Why is write_notify_reply still called?
